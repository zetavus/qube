// algorithms/search/grover_class_based.qb
// í´ë˜ìŠ¤ ê¸°ë°˜ Grover ì•Œê³ ë¦¬ì¦˜ êµ¬ì¡°í™”

class GroverAlgorithm {
    constructor(n_qubits, target_state) {
        this.n_qubits = n_qubits;
        this.target_state = target_state;
        this.iterations = 0;
    }
    
    // Oracle ì •ì˜ (|10101âŸ© ì°¾ê¸°)
    fn define_oracle_circuit() {
        circuit Oracle(5) {
            // |10101âŸ© = q4=1, q3=0, q2=1, q1=0, q0=1
            apply X to q1; // 0â†’1 ë³€í™˜
            apply X to q3; // 0â†’1 ë³€í™˜
            apply CZ to (q0, q1, q2, q3, q4); // ëª¨ë‘ 1ì¼ ë•Œ ìœ„ìƒ ë’¤ì§‘ê¸°
            apply X to q1; // ë³µì›
            apply X to q3; // ë³µì›
        }
        return Oracle();
    }
    
    // Diffusion ì •ì˜
    fn define_diffusion_circuit() {
        circuit Diffusion(5) {
            apply H to ~;  // |+âŸ© â†’ |0âŸ©
            apply X to ~;  // |00000âŸ© â†’ |11111âŸ©
            apply CZ to (q0, q1, q2, q3, q4); // |11111âŸ©ì— -1 ìœ„ìƒ
            apply X to ~;  // ë³µì›
            apply H to ~;  // |0âŸ© â†’ |+âŸ©
        }
        return Diffusion();
    }
    
    // 1íšŒ Grover ë°˜ë³µ
    fn create_single_iteration() {
        circuit SingleIteration(5) {
            // Oracle
            apply X to q1; apply X to q3;
            apply CZ to (q0, q1, q2, q3, q4);
            apply X to q1; apply X to q3;
            
            // Diffusion
            apply H to ~; apply X to ~;
            apply CZ to (q0, q1, q2, q3, q4);
            apply X to ~; apply H to ~;
        }
        return SingleIteration();
    }
    
    // ì™„ì „í•œ Grover ì•Œê³ ë¦¬ì¦˜ (ì§€ì •ëœ ë°˜ë³µ íšŸìˆ˜)
    fn create_full_algorithm(iterations) {
        this.iterations = iterations;
        
        if (iterations == 1) {
            circuit Grover1(5) {
                apply H to ~; // ì´ˆê¸°í™”
                // 1íšŒ ë°˜ë³µ
                apply X to q1; apply X to q3;
                apply CZ to (q0, q1, q2, q3, q4);
                apply X to q1; apply X to q3;
                apply H to ~; apply X to ~;
                apply CZ to (q0, q1, q2, q3, q4);
                apply X to ~; apply H to ~;
            }
            return Grover1();
        }
        
        if (iterations == 4) {
            circuit Grover4(5) {
                apply H to ~; // ì´ˆê¸°í™”
                
                // 1íšŒì°¨
                apply X to q1; apply X to q3;
                apply CZ to (q0, q1, q2, q3, q4);
                apply X to q1; apply X to q3;
                apply H to ~; apply X to ~;
                apply CZ to (q0, q1, q2, q3, q4);
                apply X to ~; apply H to ~;
                
                // 2íšŒì°¨
                apply X to q1; apply X to q3;
                apply CZ to (q0, q1, q2, q3, q4);
                apply X to q1; apply X to q3;
                apply H to ~; apply X to ~;
                apply CZ to (q0, q1, q2, q3, q4);
                apply X to ~; apply H to ~;
                
                // 3íšŒì°¨
                apply X to q1; apply X to q3;
                apply CZ to (q0, q1, q2, q3, q4);
                apply X to q1; apply X to q3;
                apply H to ~; apply X to ~;
                apply CZ to (q0, q1, q2, q3, q4);
                apply X to ~; apply H to ~;
                
                // 4íšŒì°¨
                apply X to q1; apply X to q3;
                apply CZ to (q0, q1, q2, q3, q4);
                apply X to q1; apply X to q3;
                apply H to ~; apply X to ~;
                apply CZ to (q0, q1, q2, q3, q4);
                apply X to ~; apply H to ~;
            }
            return Grover4();
        }
        
        // ê¸°ë³¸ê°’: 1íšŒ ë°˜ë³µ
        return this.create_full_algorithm(1);
    }
    
    fn run_test(iterations, trials) {
        println("ğŸ¯ í´ë˜ìŠ¤ ê¸°ë°˜ Grover í…ŒìŠ¤íŠ¸");
        println("ë°˜ë³µ: {}íšŒ, ì‹œë„: {}íšŒ", iterations, trials);
        println("");
        
        success_count = 0;
        
        trial = 1;
        while (trial <= trials) {
            grover_circuit = this.create_full_algorithm(iterations);
            result = measure(grover_circuit, [0, 1, 2, 3, 4]);
            decimal = result[0] + result[1]*2 + result[2]*4 + result[3]*8 + result[4]*16;
            
            if (decimal == 21) {
                success_count = success_count + 1;
                println("ì‹œë„ {}: âœ… ì„±ê³µ", trial);
            } else {
                println("ì‹œë„ {}: âŒ ì‹¤íŒ¨ ({})", trial, decimal);
            }
            
            trial = trial + 1;
        }
        
        success_rate = (success_count * 100) / trials;
        println("");
        println("ì„±ê³µë¥ : {}% ({}/{})", success_rate, success_count, trials);
        
        return success_rate;
    }
}

fn main() {
    println("ğŸŒŸ í´ë˜ìŠ¤ ê¸°ë°˜ Grover ì•Œê³ ë¦¬ì¦˜");
    println("==============================");
    println("");
    
    // Grover ì•Œê³ ë¦¬ì¦˜ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
    grover = GroverAlgorithm(5, 21); // 5íë¹—, ëª©í‘œê°’ 21
    
    // 1íšŒ ë°˜ë³µ í…ŒìŠ¤íŠ¸
    println("ğŸ“Š 1íšŒ ë°˜ë³µ í…ŒìŠ¤íŠ¸:");
    rate_1 = grover.run_test(1, 5);
    
    println("");
    println("ğŸ“Š 4íšŒ ë°˜ë³µ í…ŒìŠ¤íŠ¸:");
    rate_4 = grover.run_test(4, 5);
    
    println("");
    println("ğŸ† ìµœì¢… ë¹„êµ:");
    println("=============");
    println("â€¢ 1íšŒ ë°˜ë³µ: {}%", rate_1);
    println("â€¢ 4íšŒ ë°˜ë³µ: {}%", rate_4);
    
    if (rate_4 > rate_1) {
        improvement = rate_4 - rate_1;
        println("â€¢ ê°œì„ íš¨ê³¼: {}%p", improvement);
    }
    
    println("");
    println("ğŸ¯ êµ¬ì¡°ì  ì¥ì :");
    println("===============");
    println("âœ… Oracleê³¼ Diffusion ê°œë…ì  ë¶„ë¦¬");
    println("âœ… ë°˜ë³µ íšŸìˆ˜ë³„ ì•Œê³ ë¦¬ì¦˜ ìº¡ìŠí™”");
    println("âœ… ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì»´í¬ë„ŒíŠ¸ ì„¤ê³„");
    println("âœ… ê°ì²´ì§€í–¥ì  ì–‘ì í”„ë¡œê·¸ë˜ë°");
}