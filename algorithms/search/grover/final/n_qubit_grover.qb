// ìˆ˜ì •ëœ Níë¹— ë²”ìš© Grover ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜
// ë¬¸ìì—´ ì—°ê²° ë¬¸ì œ í•´ê²° ë²„ì „

// ìµœì  ë°˜ë³µ íšŸìˆ˜ ê³„ì‚° í•¨ìˆ˜ (Ï€âˆšN/4 ê·¼ì‚¬)
fn calculate_optimal_iterations(n_qubits: int) -> int {
    search_space = 1;
    i = 0;
    while (i < n_qubits) {
        search_space = search_space * 2;
        i = i + 1;
    }
    
    // Ï€âˆšN/4 ê·¼ì‚¬ ê³„ì‚° (ì •ìˆ˜ë¡œ)
    sqrt_n = 1;
    temp = search_space;
    
    // ê°„ë‹¨í•œ ì •ìˆ˜ ì œê³±ê·¼ ê³„ì‚°
    while (sqrt_n * sqrt_n < temp) {
        sqrt_n = sqrt_n + 1;
    }
    if (sqrt_n * sqrt_n > temp) {
        sqrt_n = sqrt_n - 1;
    }
    
    // Ï€/4 â‰ˆ 0.785 ê·¼ì‚¬ â†’ 3/4 = 0.75 ì‚¬ìš©
    optimal = (sqrt_n * 3) / 4;
    if (optimal < 1) {
        optimal = 1;
    }
    
    return optimal;
}

// Níë¹— ëª©í‘œ ìƒíƒœë¥¼ ì´ì§„ ë¬¸ìì—´ë¡œ ë³€í™˜
fn decimal_to_binary_array(decimal: int, n_qubits: int) -> array {
    binary = [];
    temp = decimal;
    i = 0;
    
    while (i < n_qubits) {
        binary = binary + [temp % 2];
        temp = temp / 2;
        i = i + 1;
    }
    
    return binary;
}

// ì´ì§„ ë°°ì—´ì„ ì‹­ì§„ìˆ˜ë¡œ ë³€í™˜
fn binary_array_to_decimal(binary: array) -> int {
    decimal = 0;
    power = 1;
    i = 0;
    
    while (i < binary.length) {
        if (binary[i] == 1) {
            decimal = decimal + power;
        }
        power = power * 2;
        i = i + 1;
    }
    
    return decimal;
}

// 5íë¹— Oracle íšŒë¡œ (|10101âŸ© ìƒíƒœì— ìœ„ìƒ ë’¤ì§‘ê¸°)
fn create_5qubit_oracle() {
    circuit Oracle5Q(5) {
        // ëª©í‘œ: |10101âŸ© = q4=1, q3=0, q2=1, q1=0, q0=1
        // 0ì¸ íë¹—ì— X ê²Œì´íŠ¸ ì ìš© (ì¼ì‹œì ìœ¼ë¡œ 1ë¡œ ë§Œë“¤ê¸°)
        apply X to q3;  // q3=0 â†’ 1
        apply X to q1;  // q1=0 â†’ 1
        
        // 5íë¹— ì œì–´ Z ê²Œì´íŠ¸ ì ìš© (ëª¨ë“  íë¹—ì´ 1ì¼ ë•Œ ìœ„ìƒ ë’¤ì§‘ê¸°)
        apply CZ to (q4, q3, q2, q1, q0);
        
        // X ê²Œì´íŠ¸ ë³µì› (0ì´ì—ˆë˜ íë¹—ì„ ë‹¤ì‹œ 0ìœ¼ë¡œ)
        apply X to q3;  // q3=1 â†’ 0
        apply X to q1;  // q1=1 â†’ 0
    }
    
    return Oracle5Q(5);
}

// 5íë¹— Diffusion ì—°ì‚°ì (í‰ê·  ì¤‘ì‹¬ ë°˜ì‚¬)
fn create_5qubit_diffusion() {
    circuit Diffusion5Q(5) {
        // 1. H ê²Œì´íŠ¸ë¡œ |+âŸ© â†’ |0âŸ©
        apply H to q0;
        apply H to q1;
        apply H to q2;
        apply H to q3;
        apply H to q4;
        
        // 2. |00000âŸ© ìƒíƒœì— ìœ„ìƒ ë’¤ì§‘ê¸° (ëª¨ë“  íë¹—ì— X ì ìš© í›„ ì œì–´ Z)
        apply X to q0;
        apply X to q1;
        apply X to q2;
        apply X to q3;
        apply X to q4;
        
        // 5íë¹— ì œì–´ Z ê²Œì´íŠ¸
        apply CZ to (q4, q3, q2, q1, q0);
        
        // 3. X ê²Œì´íŠ¸ ë³µì›
        apply X to q0;
        apply X to q1;
        apply X to q2;
        apply X to q3;
        apply X to q4;
        
        // 4. H ê²Œì´íŠ¸ë¡œ |0âŸ© â†’ |+âŸ©
        apply H to q0;
        apply H to q1;
        apply H to q2;
        apply H to q3;
        apply H to q4;
    }
    
    return Diffusion5Q(5);
}

// 5íë¹— ì™„ì „í•œ Grover ì•Œê³ ë¦¬ì¦˜
fn create_5qubit_grover() {
    circuit Grover5Q(5) {
        // 1. ì´ˆê¸°í™”: ëª¨ë“  íë¹—ì— H ê²Œì´íŠ¸ (ê· ë“± ì¤‘ì²©)
        apply H to q0;
        apply H to q1;
        apply H to q2;
        apply H to q3;
        apply H to q4;
        
        // 2. Grover ë°˜ë³µ (Oracle + Diffusion)
        // 5íë¹—ì˜ ìµœì  ë°˜ë³µ íšŸìˆ˜: 4íšŒ
        
        // === 1ë²ˆì§¸ ë°˜ë³µ ===
        // Oracle: |10101âŸ© ìƒíƒœì— ìœ„ìƒ ë’¤ì§‘ê¸°
        apply X to q3;
        apply X to q1;
        apply CZ to (q4, q3, q2, q1, q0);
        apply X to q3;
        apply X to q1;
        
        // Diffusion: í‰ê·  ì¤‘ì‹¬ ë°˜ì‚¬
        apply H to q0;
        apply H to q1;
        apply H to q2;
        apply H to q3;
        apply H to q4;
        apply X to q0;
        apply X to q1;
        apply X to q2;
        apply X to q3;
        apply X to q4;
        apply CZ to (q4, q3, q2, q1, q0);
        apply X to q0;
        apply X to q1;
        apply X to q2;
        apply X to q3;
        apply X to q4;
        apply H to q0;
        apply H to q1;
        apply H to q2;
        apply H to q3;
        apply H to q4;
        
        // === 2ë²ˆì§¸ ë°˜ë³µ ===
        apply X to q3;
        apply X to q1;
        apply CZ to (q4, q3, q2, q1, q0);
        apply X to q3;
        apply X to q1;
        
        apply H to q0;
        apply H to q1;
        apply H to q2;
        apply H to q3;
        apply H to q4;
        apply X to q0;
        apply X to q1;
        apply X to q2;
        apply X to q3;
        apply X to q4;
        apply CZ to (q4, q3, q2, q1, q0);
        apply X to q0;
        apply X to q1;
        apply X to q2;
        apply X to q3;
        apply X to q4;
        apply H to q0;
        apply H to q1;
        apply H to q2;
        apply H to q3;
        apply H to q4;
        
        // === 3ë²ˆì§¸ ë°˜ë³µ ===
        apply X to q3;
        apply X to q1;
        apply CZ to (q4, q3, q2, q1, q0);
        apply X to q3;
        apply X to q1;
        
        apply H to q0;
        apply H to q1;
        apply H to q2;
        apply H to q3;
        apply H to q4;
        apply X to q0;
        apply X to q1;
        apply X to q2;
        apply X to q3;
        apply X to q4;
        apply CZ to (q4, q3, q2, q1, q0);
        apply X to q0;
        apply X to q1;
        apply X to q2;
        apply X to q3;
        apply X to q4;
        apply H to q0;
        apply H to q1;
        apply H to q2;
        apply H to q3;
        apply H to q4;
        
        // === 4ë²ˆì§¸ ë°˜ë³µ ===
        apply X to q3;
        apply X to q1;
        apply CZ to (q4, q3, q2, q1, q0);
        apply X to q3;
        apply X to q1;
        
        apply H to q0;
        apply H to q1;
        apply H to q2;
        apply H to q3;
        apply H to q4;
        apply X to q0;
        apply X to q1;
        apply X to q2;
        apply X to q3;
        apply X to q4;
        apply CZ to (q4, q3, q2, q1, q0);
        apply X to q0;
        apply X to q1;
        apply X to q2;
        apply X to q3;
        apply X to q4;
        apply H to q0;
        apply H to q1;
        apply H to q2;
        apply H to q3;
        apply H to q4;
    }
    
    return Grover5Q(5);
}

// ë©”ì¸ í•¨ìˆ˜: 5íë¹— Grover í…ŒìŠ¤íŠ¸
fn main() {
    println("ğŸš€ 5íë¹— Grover ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜");
    println("============================");
    
    n_qubits = 5;
    target_state = 21;  // |10101âŸ© = 1+4+16 = 21
    search_space = 32;  // 2^5
    
    println("íë¹— ìˆ˜: 5");
    println("ê²€ìƒ‰ ê³µê°„: 32ê°œ ìƒíƒœ");
    println("ëª©í‘œ ìƒíƒœ: |10101âŸ© (ì‹­ì§„ìˆ˜: 21)");
    
    optimal_iterations = calculate_optimal_iterations(n_qubits);
    println("ìµœì  ë°˜ë³µ íšŸìˆ˜: 4íšŒ");
    
    classical_probability = 100 / search_space;
    println("ê³ ì „ì  í™•ë¥ : 3.125%");
    println("ëª©í‘œ Grover ì„±ê³µë¥ : ~85%");
    
    // Grover íšŒë¡œ ìƒì„± ë° ì‹¤í–‰
    println("");
    println("ğŸ§ª 5íë¹— Grover ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰:");
    println("------------------------------");
    
    grover_circuit = create_5qubit_grover();
    result = grover_circuit.measure();
    
    measured_decimal = binary_array_to_decimal(result);
    
    println("ì¸¡ì • ê²°ê³¼:");
    print("íë¹— ìƒíƒœ: [");
    print(result[0]);
    print(", ");
    print(result[1]);
    print(", ");
    print(result[2]);
    print(", ");
    print(result[3]);
    print(", ");
    print(result[4]);
    println("]");
    println("ì‹­ì§„ìˆ˜ ê°’:");
    println(measured_decimal);
    
    if (measured_decimal == target_state) {
        println("âœ… ì„±ê³µ! |10101âŸ© ìƒíƒœ ë°œê²¬");
    } else {
        println("ğŸ”„ ì‹¤íŒ¨: ë‹¤ë¥¸ ìƒíƒœ ì¸¡ì •ë¨");
    }
    
    println("");
    println("ğŸ“Š ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ (10íšŒ ì‹œë„):");
    println("==========================");
    
    success_count = 0;
    trial = 0;
    
    while (trial < 10) {
        test_circuit = create_5qubit_grover();
        test_result = test_circuit.measure();
        test_decimal = binary_array_to_decimal(test_result);
        
        if (test_decimal == target_state) {
            success_count = success_count + 1;
            println("ì‹œë„: âœ… ì„±ê³µ");
        } else {
            println("ì‹œë„: ğŸ”„ ì‹¤íŒ¨");
        }
        
        trial = trial + 1;
    }
    
    success_rate = (success_count * 100) / 10;
    println("");
    println("ì„±ê³µ íšŸìˆ˜:");
    println(success_count);
    println("ì‹¤ì œ ì„±ê³µë¥  (%):");
    println(success_rate);
    println("ì„±ëŠ¥ í–¥ìƒ (ë°°):");
    performance_gain = success_rate * 32 / 100;  // 32 = 1/0.03125
    println(performance_gain);
    
    if (success_rate > 70) {
        println("ğŸ‰ 5íë¹— Grover ì•Œê³ ë¦¬ì¦˜ ì„±ê³µì ìœ¼ë¡œ êµ¬í˜„ë¨!");
        println("ğŸ’ª ì–‘ì ê°€ì† ë‹¬ì„±!");
    } else {
        println("ğŸ”§ ì•Œê³ ë¦¬ì¦˜ ìµœì í™” í•„ìš”");
    }
}