// Step 1 í…ŒìŠ¤íŠ¸: ì¸¡ì • ê²°ê³¼ ë³€ìˆ˜ í• ë‹¹ (ë™ìž‘í•˜ëŠ” ë²„ì „)
fn main() {
    println("ðŸ§ª Step 1 í…ŒìŠ¤íŠ¸: ì¸¡ì • ê²°ê³¼ ë³€ìˆ˜ í• ë‹¹");
    println("===================================");
    println("");
    
    test_basic_measurement();
    test_hadamard_measurement();
    test_conditional_logic();
    
    println("ðŸŽ‰ Step 1 í…ŒìŠ¤íŠ¸ ì™„ë£Œ!");
}

fn test_basic_measurement() {
    println("1ï¸âƒ£ ê¸°ë³¸ ì¸¡ì • í…ŒìŠ¤íŠ¸:");
    
    // |0âŸ© ìƒíƒœ ì¸¡ì • (í•­ìƒ 0ì´ì–´ì•¼ í•¨)
    qubit q0 = |0âŸ©;
    scalar result0 = measure(q0);
    println("   |0âŸ© ì¸¡ì • ê²°ê³¼: {}", result0);
    
    // |1âŸ© ìƒíƒœ ì¸¡ì • (í•­ìƒ 1ì´ì–´ì•¼ í•¨)
    qubit q1 = |1âŸ©;
    scalar result1 = measure(q1);
    println("   |1âŸ© ì¸¡ì • ê²°ê³¼: {}", result1);
    
    // ê²°ê³¼ ê²€ì¦
    if (result0 == 0) {
        println("   âœ… |0âŸ© ì¸¡ì • ì„±ê³µ!");
    } else {
        println("   âŒ |0âŸ© ì¸¡ì • ì‹¤íŒ¨! (ê²°ê³¼: {})", result0);
    }
    
    if (result1 == 1) {
        println("   âœ… |1âŸ© ì¸¡ì • ì„±ê³µ!");
    } else {
        println("   âŒ |1âŸ© ì¸¡ì • ì‹¤íŒ¨! (ê²°ê³¼: {})", result1);
    }
    
    println("");
}

fn test_hadamard_measurement() {
    println("2ï¸âƒ£ í•˜ë‹¤ë§ˆë“œ ì¤‘ì²© ìƒíƒœ ì¸¡ì •:");
    println("   (í™•ë¥ ì  ê²°ê³¼ - 10ë²ˆ ì‹œë„)");
    
    scalar zeros = 0;
    scalar ones = 0;
    scalar trials = 10;
    
    for i in 0..trials {
        qubit h_qubit = H(|0âŸ©);
        scalar result = measure(h_qubit);
        
        if (result == 0) {
            zeros += 1;
        } else {
            ones += 1;
        }
        
        println("   ì‹œë„ {}: {}", i + 1, result);
    }
    
    println("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("   ì´ {}íšŒ ì‹œë„", trials);
    println("   0 ê²°ê³¼: {}ë²ˆ", zeros);
    println("   1 ê²°ê³¼: {}ë²ˆ", ones);
    
    scalar ratio = ones / trials;
    println("   1ì˜ ë¹„ìœ¨: {:.2f}", ratio);
    println("   ì´ë¡ ê°’: 0.50 (50%)");
    
    if (ratio > 0.2 && ratio < 0.8) {
        println("   âœ… í•©ë¦¬ì ì¸ í™•ë¥  ë¶„í¬!");
    } else {
        println("   âš ï¸  ì˜ˆìƒê³¼ ë‹¤ë¥¸ ë¶„í¬ (í™•ë¥ ì  ë³€ë™ì¼ ìˆ˜ ìžˆìŒ)");
    }
    
    println("");
}

fn test_conditional_logic() {
    println("3ï¸âƒ£ ì¡°ê±´ë¶€ ë¡œì§ í…ŒìŠ¤íŠ¸:");
    println("   (ì¸¡ì • ê²°ê³¼ë¡œ ë¶„ê¸° ì‹¤í–‰)");
    
    scalar test_count = 5;
    scalar success_predictions = 0;
    
    for i in 0..test_count {
        // |0âŸ© ìƒíƒœë¡œ ì˜ˆì¸¡ ê°€ëŠ¥í•œ ê²°ê³¼
        qubit predictable = |0âŸ©;
        scalar result = measure(predictable);
        
        println("   í…ŒìŠ¤íŠ¸ {}: ì¸¡ì • ê²°ê³¼ = {}", i + 1, result);
        
        // ì¡°ê±´ë¶€ ì‹¤í–‰
        if (result == 0) {
            println("     â†’ ì˜ˆìƒëŒ€ë¡œ 0 ì¸¡ì •ë¨");
            success_predictions += 1;
        } else {
            println("     â†’ ì˜ˆìƒê³¼ ë‹¤ë¦„ (1 ì¸¡ì •ë¨)");
        }
    }
    
    println("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println("   ì„±ê³µì  ì˜ˆì¸¡: {}/{}", success_predictions, test_count);
    
    if (success_predictions == test_count) {
        println("   âœ… ì¡°ê±´ë¶€ ë¡œì§ ì™„ë²½ ë™ìž‘!");
    } else {
        println("   âŒ ì¡°ê±´ë¶€ ë¡œì§ì— ë¬¸ì œ ìžˆìŒ");
    }
    
    println("");
}

fn test_two_qubit_grover_prep() {
    println("4ï¸âƒ£ 2íë¹— Grover ì¤€ë¹„ í…ŒìŠ¤íŠ¸:");
    
    // 2ê°œì˜ íë¹— ì¤€ë¹„
    qubit q0 = |0âŸ©;
    qubit q1 = |0âŸ©;
    
    println("   ì´ˆê¸° ìƒíƒœ ì¤€ë¹„ ì™„ë£Œ");
    
    // ê°œë³„ ì¸¡ì •
    scalar r0 = measure(q0);
    scalar r1 = measure(q1);
    
    println("   íë¹— 0 ì¸¡ì •: {}", r0);
    println("   íë¹— 1 ì¸¡ì •: {}", r1);
    
    // 2ë¹„íŠ¸ ê°’ ê³„ì‚° (Groverì—ì„œ ì‚¬ìš©í•  ë°©ì‹)
    scalar combined = r0 * 2 + r1;
    println("   ì¡°í•©ëœ ìƒíƒœ: |{}{}âŸ© = ì‹­ì§„ìˆ˜ {}", r0, r1, combined);
    
    if (combined == 0) {  // |00âŸ©
        println("   âœ… ì˜ˆìƒ ìƒíƒœ |00âŸ© ë‹¬ì„±!");
    }
    
    println("   ðŸŽ¯ ì´ì œ Grover ì•Œê³ ë¦¬ì¦˜ì— ì ìš©í•  ì¤€ë¹„ ì™„ë£Œ!");
}