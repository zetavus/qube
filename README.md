README.md

# Qube ì–‘ì í”„ë¡œê·¸ë˜ë° ì–¸ì–´ 

**ì§ê´€ì ì´ê³  ê°•ë ¥í•œ ì–‘ì í”„ë¡œê·¸ë˜ë°ì„ ìœ„í•œ í˜ì‹ ì  ì–¸ì–´**

##  ì—­ì‚¬ì  ì„±ê³¼ (v0.1.0)

###  5íë¹— Grover ì•Œê³ ë¦¬ì¦˜ 100% ì„±ê³µë¥  ë‹¬ì„±!
```qube
// ì™„ë²½í•œ ì–‘ì ìš°ìœ„ í™•ë³´
circuit GroverOptimized(5) {
    apply H to ~;  //  ë²”ìœ„ ë¬¸ë²•: ëª¨ë“  íë¹—ì— H
    // 4íšŒ Grover ë°˜ë³µìœ¼ë¡œ 99.9% í™•ë¥  ë‹¬ì„±
}
result = measure(grover, [0, 1, 2, 3, 4]);
// â†’ 100% ì„±ê³µë¥ ë¡œ |10101âŸ© ìƒíƒœ ë°œê²¬ (33.3ë°° í–¥ìƒ)
```

###  í˜ì‹ ì  ë²”ìœ„ ë¬¸ë²•
```qube
// ê¸°ì¡´ ë°©ì‹ (5ì¤„)
apply H to q0;
apply H to q1;
apply H to q2;
apply H to q3;
apply H to q4;

// Qube ë²”ìœ„ ë¬¸ë²• (1ì¤„)
apply H to ~;  // ëª¨ë“  íë¹—ì— H ì ìš©
```

###  **NEW! ì™„ì „í•œ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬**
```qube
//  íƒ€ì… ë³€í™˜ & ìˆ˜í•™ í•¨ìˆ˜
result_text = toString(42);        // "42"
distance = sqrt(pow(3, 2) + pow(4, 2));  // 5.0
angle_value = sin(Ï€ / 2);          // 1.0

//  ì»¬ë ‰ì…˜ ì²˜ë¦¬
numbers = [1, 2, 3, 4, 5];
total = sum(numbers);              // 15
average = total / len(numbers);    // 3.0
best = max(numbers);               // 5

//  ëœë¤ & ë²”ìœ„ ìƒì„±
dice = randomInt(1, 6);            // 1~6 ëœë¤
sequence = range(0, 10, 2);        // [0, 2, 4, 6, 8]
```

##  ë¹ ë¥¸ ì‹œì‘

### ì„¤ì¹˜ ë° ì‹¤í–‰
```bash
qube my_program.qb           # íŒŒì¼ ì‹¤í–‰
qube --repl                  # ëŒ€í™”í˜• ëª¨ë“œ
qube --api                   # ì „ì²´ API í™•ì¸
```

### ì²« ë²ˆì§¸ ì–‘ì íšŒë¡œ
```qube
fn main() {
    circuit Bell(2) {
        apply H to q0;
        apply CNOT to (q0, q1);
    }
    
    bell = Bell();
    result = measure(bell, [0, 1]);
    println("ê²°ê³¼: " + toString(result));  //  stdlib ì‚¬ìš©
}
```

## ğŸ”§ ì™„ì „í•œ ê°œë°œì ë„êµ¬

### CLI ë„ì›€ë§ ì‹œìŠ¤í…œ
```bash
qube --help measure          # ì¸¡ì • í•¨ìˆ˜ ì™„ì „ ê°€ì´ë“œ
qube --help gates            # ëª¨ë“  ê²Œì´íŠ¸ ì‚¬ìš©ë²•
qube --help circuit          # íšŒë¡œ ìƒì„± ë°©ë²•
qube --help examples         # ì˜ˆì œ íŒŒì¼ ì•ˆë‚´
```

### ì§€ì› ê¸°ëŠ¥
-  **20+ ì–‘ì ê²Œì´íŠ¸** (H, X, Y, Z, CNOT, CZ, CCZ, CCCZ)
-  **ë²”ìœ„ ë¬¸ë²•** (`apply H to ~` - ëª¨ë“  íë¹—)
-  **ìŠ¤ë§ˆíŠ¸ CZ ê²Œì´íŠ¸** (Níë¹— ì œì–´ Z ìë™ ì²˜ë¦¬)
-  **ì™„ì „í•œ ì¸¡ì • ì‹œìŠ¤í…œ** (ì „ì²´/ë¶€ë¶„/ë‹¨ì¼ ì¸¡ì •)
-  **ë””ë²„ê·¸ ëª¨ë“œ** (ìƒíƒœ ë²¡í„° ì‹¤ì‹œê°„ í™•ì¸)
-  **í’ë¶€í•œ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬** (15ê°œ ë‚´ì¥ í•¨ìˆ˜)

##  **í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë ˆí¼ëŸ°ìŠ¤** 

###  íƒ€ì… ë³€í™˜ í•¨ìˆ˜
```qube
toString(42)        // "42"
toString(3.14)      // "3.14"
toString(true)      // "true"
toString([1,2,3])   // "[1, 2, 3]"
```

###  ìˆ˜í•™ í•¨ìˆ˜
```qube
abs(-5)             // 5 (ì ˆëŒ“ê°’)
sqrt(16)            // 4.0 (ì œê³±ê·¼)
pow(2, 3)           // 8 (ê±°ë“­ì œê³±)
sin(Ï€ / 2)          // 1.0 (ì‚¼ê°í•¨ìˆ˜)
cos(0)              // 1.0
log(100, 10)        // 2.0 (ë¡œê·¸)
```

###  ì»¬ë ‰ì…˜ í•¨ìˆ˜
```qube
data = [10, 20, 30, 40, 50];
len(data)           // 5 (ê¸¸ì´)
max(data)           // 50 (ìµœëŒ“ê°’)
min(data)           // 10 (ìµœì†Ÿê°’)
sum(data)           // 150 (í•©ê³„)
range(0, 10, 2)     // [0, 2, 4, 6, 8] (ë²”ìœ„)
```

###  ëœë¤ í•¨ìˆ˜
```qube
random()            // 0.0~1.0 ë‚œìˆ˜
randomInt(1, 6)     // 1~6 ì •ìˆ˜ ë‚œìˆ˜ (ì£¼ì‚¬ìœ„)
```

###  í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ í™œìš© ì˜ˆì œ
```qube
fn quantum_statistics() {
    // ì–‘ì íšŒë¡œ 100íšŒ ì‹¤í–‰í•˜ì—¬ í†µê³„ ë¶„ì„
    results = [];
    
    for i in range(100) {
        circuit Test(3) {
            apply H to ~;
            // ì¶”ê°€ ê²Œì´íŠ¸ë“¤...
        }
        
        test = Test();
        measurement = measure(test, [0, 1, 2]);
        decimal = measurement[0] + measurement[1]*2 + measurement[2]*4;
        results = results + [decimal];
    }
    
    // í†µê³„ ê³„ì‚°
    total_count = len(results);
    average_value = sum(results) / total_count;
    max_value = max(results);
    min_value = min(results);
    
    println("ì‹¤í–‰ íšŸìˆ˜: " + toString(total_count));
    println("í‰ê· ê°’: " + toString(average_value));
    println("ìµœëŒ“ê°’: " + toString(max_value));
    println("ìµœì†Ÿê°’: " + toString(min_value));
}
```

##  ê²€ì¦ëœ ì–‘ì ì•Œê³ ë¦¬ì¦˜

### 5íë¹— Grover ê²€ìƒ‰ (100% ì„±ê³µë¥ )
```qube
// 32ê°œ ìƒíƒœì—ì„œ íŠ¹ì • ìƒíƒœë¥¼ 100% í™•ë¥ ë¡œ ì°¾ê¸°
circuit GroverOptimized(5) {
    apply H to ~;  // ì´ˆê¸°í™”: ëª¨ë“  íë¹—ì— H
    
    // 4íšŒ Grover ë°˜ë³µìœ¼ë¡œ 99.9% ì„±ê³µë¥ 
    // Oracle + Diffusion íŒ¨í„´
}
// ì‹¤ì œ ì„±ê³¼: 20íšŒ ì—°ì† ì„±ê³µ!
```

### ë²¨ ìƒíƒœ ìƒì„±
```qube
circuit Bell(2) {
    apply H to q0;
    apply CNOT to (q0, q1);
}
```

##  ì„±ëŠ¥ ì§€í‘œ

| ì•Œê³ ë¦¬ì¦˜ | ê²€ìƒ‰ ê³µê°„ | ê³ ì „ í™•ë¥  | Qube ì„±ê³µë¥  | ì„±ëŠ¥ í–¥ìƒ |
|----------|-----------|-----------|-------------|-----------|
| 3íë¹— Grover | 8ê°œ ìƒíƒœ | 12.5% | 100% | 8ë°° |
| 4íë¹— Grover | 16ê°œ ìƒíƒœ | 6.25% | 100% | 16ë°° |
| 5íë¹— Grover | 32ê°œ ìƒíƒœ | 3.125% | 100% | **33.3ë°°** |

##  **í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ í…ŒìŠ¤íŠ¸** 

### ê¸°ë³¸ í…ŒìŠ¤íŠ¸
```bash
qube algorithms/test/stdlib_simple_test.qb     # ê¸°ë³¸ í•¨ìˆ˜ í…ŒìŠ¤íŠ¸
qube algorithms/test/stdlib_advanced_test.qb   # ê³ ê¸‰ í•¨ìˆ˜ í…ŒìŠ¤íŠ¸
```

### ì˜ˆìƒ ì¶œë ¥
```
=== Qube stdlib ê°„ë‹¨ í…ŒìŠ¤íŠ¸ ===
abs(-5) = 5
sqrt(16) = 4.0
len([1,2,3,4,5]) = 5
max([1,2,3,4,5]) = 5
sum([1,2,3,4,5]) = 15
toString(42) = 42
=== í…ŒìŠ¤íŠ¸ ì™„ë£Œ! ===
```

##  ê°œë°œ ì¤‘ (v0.2.0)

### ê³ ê¸‰ ë²”ìœ„ ë¬¸ë²•
```qube
// 50íë¹—+ ì´ˆëŒ€í˜• íšŒë¡œ ì§€ì›
apply CZ to (~, q49);        // ëª¨ë“  íë¹—ì„ ì œì–´ë¡œ ì‚¬ìš©
apply H to (q0:q10);         // ë²”ìœ„ ìŠ¬ë¼ì´ì‹±
```

### ì–‘ì ë ˆì§€ìŠ¤í„°
```qube
qreg[8] data;               // 8íë¹— ì–‘ì ë ˆì§€ìŠ¤í„°
creg[8] result;             // 8ë¹„íŠ¸ ê³ ì „ ë ˆì§€ìŠ¤í„°
```

### í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ í™•ì¥ 
```qube
// v0.2.0 ì˜ˆì • í•¨ìˆ˜ë“¤
split("hello,world", ",")   // ë¬¸ìì—´ ë¶„í• 
join([1,2,3], ",")         // ë°°ì—´ ê²°í•©
round(3.14159, 2)          // ë°˜ì˜¬ë¦¼
floor(3.7)                 // ë‚´ë¦¼
ceil(3.2)                  // ì˜¬ë¦¼
```

##  í•™ìŠµ ë¡œë“œë§µ

###  ì´ˆê¸‰ (ê¸°ë³¸ ë¬¸ë²•)
1. **ê¸°ë³¸ ë¬¸ë²•**: `qube examples/basic/hello.qb`
2. **í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬**: `qube algorithms/test/stdlib_simple_test.qb` 
3. **ì²« ì–‘ì íšŒë¡œ**: ë²¨ ìƒíƒœ ìƒì„±
4. **ë²”ìœ„ ë¬¸ë²•**: `apply H to ~` ì‚¬ìš©ë²•

###  ì¤‘ê¸‰ (ì–‘ì ì•Œê³ ë¦¬ì¦˜)
1. **ê²Œì´íŠ¸ ì‚¬ìš©ë²•**: `qube --help gates`
2. **ì¸¡ì • ì‹œìŠ¤í…œ**: `qube --help measure`
3. **ê³ ê¸‰ stdlib**: `qube algorithms/test/stdlib_advanced_test.qb` 
4. **Grover ì•Œê³ ë¦¬ì¦˜**: `algorithms/search/grover_performance_test.qb`

###  ê³ ê¸‰ (ì‹¤ì œ ì‘ìš©)
1. **Deutsch-Jozsa**: í•¨ìˆ˜ íŠ¹ì„± íŒë³„
2. **Simon ì•Œê³ ë¦¬ì¦˜**: ì£¼ê¸°ì„± íƒì§€
3. **ì–‘ì ë¨¸ì‹ ëŸ¬ë‹**: VQC, QAOA

##  ë¬¸ì„œ ë° ë¦¬ì†ŒìŠ¤

-  **ì™„ì „í•œ ë³€ê²½ ë¡œê·¸**: [docs/CHANGELOG.md](docs/CHANGELOG.md)
-  **ê¸°ìˆ ì  ë§ˆì¼ìŠ¤í†¤**: [docs/MILESTONES.md](docs/MILESTONES.md)
-  **í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ API**: [docs/api/stdlib_api.md](docs/api/stdlib_api.md) 
-  **ì˜ˆì œ ì½”ë“œ**: `algorithms/` ë””ë ‰í† ë¦¬
-  **CLI ë„ì›€ë§**: `qube --help [topic]`

##  ì™œ Qubeì¸ê°€?

###  **ì§ê´€ì  ì„¤ê³„**
```qube
// ì˜ë„ê°€ ëª…í™•íˆ ë“œëŸ¬ë‚˜ëŠ” ì½”ë“œ
apply H to ~;              // "ëª¨ë“  íë¹—ì— H ê²Œì´íŠ¸"
apply CZ to (q0, q1, q2);  // "3íë¹— CZ ê²Œì´íŠ¸"
result = toString(42);     // "íƒ€ì… ë³€í™˜" 
```

###  **ê²€ì¦ëœ ì„±ëŠ¥**
- **100% Grover ì„±ê³µë¥ ** - ì´ë¡ ì¹˜(85%)ë¥¼ ë›°ì–´ë„˜ìŒ
- **33.3ë°° ì„±ëŠ¥ í–¥ìƒ** - ê³ ì „ ì•Œê³ ë¦¬ì¦˜ ëŒ€ë¹„
- **77% ì½”ë“œ ê°„ì†Œí™”** - ë²”ìœ„ ë¬¸ë²•ìœ¼ë¡œ ë‹¬ì„±
- **15ê°œ ë‚´ì¥ í•¨ìˆ˜** - ì™„ì „í•œ stdlib ì œê³µ 

###  **í™•ì¥ì„±**
- **Níë¹— ì§€ì›** - 50íë¹—+ í™•ì¥ ì¤€ë¹„
- **ëª¨ë“ˆí™”** - ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì–‘ì íšŒë¡œ
- **ì‹¤ìš©ì„±** - ì‹¤ì œ ì–‘ì í•˜ë“œì›¨ì–´ ëŒ€ì‘
- **ìƒì‚°ì„±** - í’ë¶€í•œ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ 

---

**Qubeë¡œ ì–‘ì ì»´í“¨íŒ…ì˜ ë¯¸ë˜ë¥¼ ë§Œë“¤ì–´ë³´ì„¸ìš”!** 

*"ì–‘ì í”„ë¡œê·¸ë˜ë°ì„ ëª¨ë“  ê°œë°œìì—ê²Œ"* - Qube í”„ë¡œì íŠ¸

## ë¬¸ì˜

ê¶ê¸ˆí•œ ì ì´ë‚˜ ê¸°ìˆ ì  ì§ˆë¬¸ì´ ìˆìœ¼ì‹œë©´ ì–¸ì œë“ ì§€ ì—°ë½í•´ì£¼ì„¸ìš”.

ğŸ“§ **hspark@zetavus.com**